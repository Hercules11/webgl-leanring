<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>最小可行性项目——绘制贴图到图形上</title>
		<style>
			@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
			body {
				margin: 0;
			}
			canvas {
				width: 100vw;
				height: 100vh;
				display: block;
			}
		</style>
	</head>
	<body>
		<canvas id="webgl"></canvas>
		<script id="vertex-shader-2d" type="notjs">
			attribute vec4 aPos;
			attribute vec2 aTexCoord;
            uniform mat4 uMatrix;
            varying vec2 vTexCoord;   // 传递到片元着色器的纹理坐标

			void main() {
			  gl_Position = uMatrix * aPos;
			  vTexCoord = aTexCoord; // 把纹理坐标传下去
			}
		</script>
		<script id="fragment-shader-2d" type="notjs">
			precision highp float;

            varying vec2 vTexCoord; // 从顶点着色器传来的纹理坐标
            uniform sampler2D uSampler; // 纹理采样器，指向我们绑定的图片

			void main() {
                // 根据纹理坐标在图片上取一个像素颜色，作为当前片元的颜色
			  gl_FragColor = texture2D(uSampler, vTexCoord);
			}
		</script>

		<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
		<script>
			"use strict";

			// 列主序矩阵乘法（修复版本）
			function multiplyMatrix(a, b) {
				const out = new Float32Array(16);
				// 对于列主序矩阵，计算公式需要调整
				for (let col = 0; col < 4; ++col) {
					for (let row = 0; row < 4; ++row) {
						out[col * 4 + row] =
							a[row + 0] * b[col * 4 + 0] +
							a[row + 4] * b[col * 4 + 1] +
							a[row + 8] * b[col * 4 + 2] +
							a[row + 12] * b[col * 4 + 3];
					}
				}
				return out;
			}

			function main() {
				const canvas = document.querySelector("#webgl");
				const gl = canvas.getContext("webgl");
				if (!gl) {
					console.error("WebGL not supported");
					return;
				}

				// 设置视口
				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

				// 获取各向异性过滤扩展
				const ext = gl.getExtension('EXT_texture_filter_anisotropic') ||
						   gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||
						   gl.getExtension('MOZ_EXT_texture_filter_anisotropic');

				const program = webglUtils.createProgramFromScripts(gl, [
					"vertex-shader-2d",
					"fragment-shader-2d",
				]);

				// 立方体顶点数据, 想象一个立方体坐标系
				const points = new Float32Array([
					// 前面
					-0.5,  0.5, -0.5,   0.5,  0.5, -0.5,   0.5, -0.5, -0.5,  -0.5, -0.5, -0.5,
					// 右面
					 0.5,  0.5, -0.5,   0.5,  0.5,  0.5,   0.5, -0.5,  0.5,   0.5, -0.5, -0.5,
					// 后面
					 0.5,  0.5,  0.5,  -0.5,  0.5,  0.5,  -0.5, -0.5,  0.5,   0.5, -0.5,  0.5,
					// 左面
					-0.5,  0.5,  0.5,  -0.5,  0.5, -0.5,  -0.5, -0.5, -0.5,  -0.5, -0.5,  0.5,
					// 上面
					-0.5,  0.5,  0.5,   0.5,  0.5,  0.5,   0.5,  0.5, -0.5,  -0.5,  0.5, -0.5,
					// 下面
					-0.5, -0.5, -0.5,   0.5, -0.5, -0.5,   0.5, -0.5,  0.5,  -0.5, -0.5,  0.5,
				]);

				// 索引数据， 利用点组成所需的三角形片元
				const indices = new Uint8Array([
					0,1,2,  0,2,3,      // 前
					4,5,6,  4,6,7,      // 右
					8,9,10, 8,10,11,    // 后
					12,13,14, 12,14,15, // 左
					16,17,18, 16,18,19, // 上
					20,21,22, 20,22,23, // 下
				]);

				// 纹理坐标
                // 为每个顶点指定纹理坐标
				// 范围 [0,1] 表示在图片上的位置
				const texCoords = new Float32Array([
					// 前面
					0,1,  1,1,  1,0,  0,0,
					// 右面
					0,1,  1,1,  1,0,  0,0,
					// 后面
					0,1,  1,1,  1,0,  0,0,
					// 左面
					0,1,  1,1,  1,0,  0,0,
					// 上面
					0,1,  1,1,  1,0,  0,0,
					// 下面
					0,1,  1,1,  1,0,  0,0,
				]);

				gl.useProgram(program);

				// 创建并设置纹理
				const texture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, texture);

					// 先放一个纯蓝色像素，避免图片未加载时报错
				gl.texImage2D(
					gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0,
					gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])
				);

				// 加载实际的纹理图片
				const image = new Image();
				// image.src = "https://webglfundamentals.org/webgl/resources/f-texture.png";
				// image.src = "hq720.webp";
				image.src = "hq720.webp";
				image.crossOrigin = "anonymous";
				image.onload = function () {
					gl.bindTexture(gl.TEXTURE_2D, texture);
					gl.texImage2D(
						gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image
					); // 把图片数据拷贝进 GPU 的纹理内存

					// 检查是否是2的幂次方
					if ((image.width & (image.width - 1)) === 0 &&
						(image.height & (image.height - 1)) === 0) {
                            // 是 2^n，生成 mipmap，多级缩小纹理
						gl.generateMipmap(gl.TEXTURE_2D);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					} else {
                        // 不是 2^n，只能使用 CLAMP_TO_EDGE
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					}

					// 如果支持各向异性过滤，则开启，增强纹理清晰度
					if (ext) {
						const max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
						gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);
					}
				};

				// 设置纹理坐标缓冲
				const aTexCoordLocation = gl.getAttribLocation(program, "aTexCoord");
				const texCoordBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
				gl.enableVertexAttribArray(aTexCoordLocation);
				gl.vertexAttribPointer(aTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

				// 设置位置缓冲
				const aPosLocation = gl.getAttribLocation(program, "aPos");
				const positionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
				gl.enableVertexAttribArray(aPosLocation);
				gl.vertexAttribPointer(aPosLocation, 3, gl.FLOAT, false, 0, 0);

				// 设置索引缓冲
				const indexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

				// 开启深度测试，保证前面遮挡后面
				gl.enable(gl.DEPTH_TEST);

				const uMatrixLocation = gl.getUniformLocation(program, "uMatrix");
				const uSamplerLocation = gl.getUniformLocation(program, "uSampler");

				// 生成列主序旋转矩阵
				function getRotationMatrix(angleX, angleY) {
					const sx = Math.sin(angleX), cx = Math.cos(angleX);
					const sy = Math.sin(angleY), cy = Math.cos(angleY);

					// 列主序绕Y轴旋转矩阵
					const rotY = new Float32Array([
						cy, 0, sy, 0,
						0, 1, 0, 0,
						-sy, 0, cy, 0,
						0, 0, 0, 1
					]);

					// 列主序绕X轴旋转矩阵
					const rotX = new Float32Array([
						1, 0, 0, 0,
						0, cx, -sx, 0,
						0, sx, cx, 0,
						0, 0, 0, 1
					]);

					// 先绕Y轴旋转，再绕X轴旋转
					return multiplyMatrix(rotY, rotX);
				}

				// 透视投影矩阵（列主序）
				function perspectiveMatrix(fov, aspect, near, far) {
					const f = 1.0 / Math.tan(fov / 2);
					const rangeInv = 1 / (near - far);

					return new Float32Array([
						f / aspect, 0, 0, 0,
						0, f, 0, 0,
						0, 0, (near + far) * rangeInv, -1,
						0, 0, near * far * rangeInv * 2, 0
					]);
				}

				// 平移矩阵（列主序）
				function translationMatrix(x, y, z) {
					return new Float32Array([
						1, 0, 0, 0,
						0, 1, 0, 0,
						0, 0, 1, 0,
						x, y, z, 1
					]);
				}

				function render(time) {
					time *= 0.001;
					const angleX = time * 0.5;
					const angleY = time * 0.7;

					// 调整canvas大小（适应窗口变化）
					if (gl.canvas.width !== gl.canvas.clientWidth ||
						gl.canvas.height !== gl.canvas.clientHeight) {
						gl.canvas.width = gl.canvas.clientWidth;
						gl.canvas.height = gl.canvas.clientHeight;
						gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
					}

					// 清除画布
					gl.clearColor(0.2, 0.2, 0.2, 1.0); // 灰色背景色，清晰看到渲染效果
					gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

					// 激活纹理单元0并绑定纹理
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, texture);
					gl.uniform1i(uSamplerLocation, 0);// 把纹理传给着色器

					// 计算变换矩阵
					const rotation = getRotationMatrix(angleX, angleY);
					const translation = translationMatrix(0, 0, -2.5); // 将Z轴平移从-3改为-2.5，使立方体在更合适的观察距离
					const projection = perspectiveMatrix(
						Math.PI / 4,
						gl.canvas.clientWidth / gl.canvas.clientHeight,
						0.1,
						100
					);

					// 组合矩阵：投影 * 平移 * 旋转
					const modelView = multiplyMatrix(translation, rotation);
					const finalMatrix = multiplyMatrix(projection, modelView);

					// 设置矩阵uniform
					gl.uniformMatrix4fv(uMatrixLocation, false, finalMatrix);

					// 绘制
					gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);

					requestAnimationFrame(render);
				}

				// 开始渲染循环
				requestAnimationFrame(render);
			}

			main();
		</script>
	</body>
</html>