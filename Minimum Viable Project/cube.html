<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>最小可行性项目——绘制立方体</title>
		<style>
			@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
			body {
				margin: 0;
			}
			canvas {
				width: 100vw;
				height: 100vh;
				display: block;
			}
		</style>
	</head>
	<body>
		<canvas id="webgl"></canvas>
		<script id="vertex-shader-2d" type="notjs">
			attribute vec4 aPos;
			attribute vec4 aColor;
            uniform mat4 uMatrix;
			varying vec4 vColor;

			void main() {
			  gl_Position = uMatrix * aPos;
			  vColor = aColor;
			}
		</script>
		<script id="fragment-shader-2d" type="notjs">
			precision mediump float;
			varying vec4 vColor;

			void main() {
			  gl_FragColor = vColor;
			}
		</script>

		<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
		<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
		<script>
			"use strict";
            function main() {
                const canvas = document.querySelector("#webgl");
                const gl = canvas.getContext("webgl");
                if (!gl) {
                    return;
                }

                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                const program = webglUtils.createProgramFromScripts(gl, [
                    "vertex-shader-2d",
                    "fragment-shader-2d",
                ]);

                const points = new Float32Array([
                    -0.5, 0.5, -0.5, 1,
                    0.5, 0.5, -0.5, 1,
                    0.5, -0.5, -0.5, 1,
                    -0.5, -0.5, -0.5, 1,
                    -0.5, 0.5, 0.5, 1,
                    0.5, 0.5, 0.5, 1,
                    0.5, -0.5, 0.5, 1,
                    -0.5, -0.5, 0.5, 1,
                ]);
                const colors = new Float32Array([
                    1, 0, 0,  1, 1, 0,  0, 1, 0,  0, 1, 1,
                    1, 0, 1,  0, 0, 1,  1, 1, 1,  0, 0, 0,
                ]);
                const indices = new Uint8Array([
                    0, 1, 2, 0, 2, 3, // 前
                    1, 5, 6, 1, 6, 2, // 右
                    5, 4, 7, 5, 7, 6, // 后
                    4, 0, 3, 4, 3, 7, // 左
                    4, 5, 1, 4, 1, 0, // 上
                    3, 2, 6, 3, 6, 7, // 下
                ]);

                gl.useProgram(program);

                const aPosLocation = gl.getAttribLocation(program, "aPos");
                const aColorLocation = gl.getAttribLocation(program, "aColor");

                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(aPosLocation);
                gl.vertexAttribPointer(aPosLocation, 4, gl.FLOAT, false, 0, 0);

                const colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(aColorLocation);
                gl.vertexAttribPointer(aColorLocation, 3, gl.FLOAT, false, 0, 0);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                gl.enable(gl.DEPTH_TEST);

                // 新增：定义旋转矩阵和 uniform
                const uMatrixLocation = gl.getUniformLocation(program, "uMatrix");

                // 新增：简单的 4x4 矩阵工具
                function getRotationMatrix(angleX, angleY) {
                    const sx = Math.sin(angleX), cx = Math.cos(angleX);
                    const sy = Math.sin(angleY), cy = Math.cos(angleY);

                    // 绕Y轴旋转
                    const rotY = [
                        cy, 0, sy, 0,
                        0, 1, 0, 0,
                        -sy, 0, cy, 0,
                        0, 0, 0, 1
                    ];
                    // 绕X轴旋转
                    const rotX = [
                        1, 0, 0, 0,
                        0, cx, -sx, 0,
                        0, sx, cx, 0,
                        0, 0, 0, 1
                    ];
                    // 乘法 rotY * rotX
                    const m = new Float32Array(16);
                    for (let row = 0; row < 4; ++row) {
                        for (let col = 0; col < 4; ++col) {
                            m[row * 4 + col] =
                                rotY[row * 4 + 0] * rotX[0 * 4 + col] +
                                rotY[row * 4 + 1] * rotX[1 * 4 + col] +
                                rotY[row * 4 + 2] * rotX[2 * 4 + col] +
                                rotY[row * 4 + 3] * rotX[3 * 4 + col];
                        }
                    }
                    return m;
                }
                // 使用两层循环把rotX, rotY 相乘，得到一个最终的 4x4 矩阵，包含 X 的旋转和 Y 的旋转，最后把矩阵传给 shader, 控制顶点的变换

                let lastTime = 0;
                function render(time) {
                    time *= 0.001; // 毫秒 → 秒
                    const angleX = time; // 1 rad/s
                    const angleY = time * 0.7; // 0.7 rad/s

                    // 先清空画布，设置白色背景。
                    gl.clearColor(1, 1, 1, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    // 把旋转矩阵传给 shader，调用 gl.drawElements 按照索引画三角形。
                    const matrix = getRotationMatrix(angleX, angleY);
                    gl.uniformMatrix4fv(uMatrixLocation, false, matrix);

                    // 每一帧都用新的角度重算矩阵 → 传到 shader → 重新绘制 → 下一帧继续。
                    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);

                    requestAnimationFrame(render);
                }

                render(lastTime);
            }
			main();
		</script>
	</body>
</html>
