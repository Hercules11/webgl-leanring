<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>最小可行性项目——绘制三角形</title>
		<style>
			@import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");
			body {
				margin: 0;
			}
			canvas {
				width: 100vw;
				height: 100vh;
				display: block;
			}
		</style>
	</head>
	<body>
		<canvas id="webgl"></canvas>
        <script id="vertex-shader-2d" type="notjs">
            attribute vec4 a_position;

            void main() {
                // gl_Position 是一个特殊变量，顶点着色器负责设置它
                // 这里将顶点位置直接传递给 gl_Position
                gl_Position = a_position; // 定顶点的位置的，告诉 OpenGL 这个顶点在 NDC(标准化设备坐标) 中的坐标
            }
        </script>
        <script id="fragment-shader-2d" type="notjs">
            precision mediump float;

            uniform vec4 u_color;

            void main() {
                // 设置片元颜色
                gl_FragColor = u_color;
            }
        </script>

            		<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
		<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
		<script>
            "use strict";
            function main() {
                const canvas = document.querySelector("#webgl");
                const gl = canvas.getContext("webgl");
                if(!gl) {
                    return;
                }

                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // 告诉 webgl 如何将 0 到 1 坐标 变为屏幕上的坐标


                const program = webglUtils.createProgramFromScripts(gl, [
                    "vertex-shader-2d",
                    "fragment-shader-2d", // createShader, shaderSource, compileShader have been included
                ]); // createProgram, attachShader, linkProgram have been included
                gl.useProgram(program);

                const positionLocation = gl.getAttribLocation(program, "a_position"); // 获取顶点位置属性的位置
                const colorLocation = gl.getUniformLocation(program, "u_color"); // 获取颜色 uniform 的位置
                gl.uniform4f(colorLocation, 0.26, 0.54, 0.96, 1); // 设置为谷歌蓝（偏浅色）


                // createBuffer, bindBuffer, bufferData
                const positionBuffer = gl.createBuffer(); // 创建一个缓冲区, 存放顶点缓冲对象(三角形的顶点数据)，返回其 ID
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // 绑定缓冲区到 ARRAY_BUFFER， 后续对 gl.ARRAY_BUFFER 的操作都会映射到这个缓存
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    0, 0.5, // 顶点1
                    -0.5, -0.5, // 顶点2
                    0.5, -0.5 // 顶点3,  因为会将数据发送到 GPU，为了省去数据解析，这里使用 Float32Array 直接传送数据
                ]), gl.STATIC_DRAW); // 将顶点数据传入缓冲区, 表示缓冲区的内容不会经常更改


                // 现在我们需要告诉 WebGL 如何从缓冲区中读取数据
                gl.enableVertexAttribArray(positionLocation); // 启用顶点属性数组
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0); // 告诉 WebGL 如何解析缓冲区中的数据
                // 第一个参数是属性位置，第二个参数是每个顶点的分量数（2D 坐标），第三个参数是数据类型，
                // 第四个参数是是否归一化，第五个参数是步长， stride 步长 数组中一行长度，0 表示数据是紧密的没有空隙，让OpenGL决定具体步长，第六个参数是偏移量， offset 字节偏移量，必须是类型的字节长度的倍数。

                // 清除画布
                gl.clearColor(1, 1, 1, 1); // 设置清除颜色为黑色
                gl.clear(gl.COLOR_BUFFER_BIT); // 清除画布，清空颜色缓存

                // 绘制三角形, 从那个点开始画，画多少个点
                gl.drawArrays(gl.TRIANGLES, 0, 3); // 绘制三角形，使用 gl.TRIANGLES 模式，从缓冲区的起始位置开始绘制 3 个顶点
            }
            main();
        </script>
	</body>
</html>
